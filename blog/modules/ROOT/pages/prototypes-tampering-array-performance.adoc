= Valiant V8: prototypes tampering and Array operations performance
Guillaume Grossetie <ggrossetie@yuzutech.fr>
:page-revdate: 2020-10-04 19:00
:page-author: Guillaume Grossetie
:description: TODO
:page-tags: V8, JavaScript, performance
//:page-image: come.jpeg
:page-color-primary: #8BB3B2
:page-color-secondary: #C68B45
:source-highlighter: highlight.js


- Introduce V8 (short)
- Introduce prototypes tampering
- Introduce fast paths (and conditions)
- Microbenchmarks
- Faster implementation
- General implementation

V8 is a high-performance JavaScript engine most notably used in Chrome and in Node.js.
It comes as no surprise that the V8 team is working hard to continously improve the performance and make JavaScript as fast as possible.

A common strategy, used by V8 developers, is to optimize operations based on the elements kinds.

> In fact, while running JavaScript code, V8 keeps track of what kind of elements each array contains.
> This information allows V8 to optimize any operations on the array specifically for this type of element.
> For example, when you call `reduce`, `map`, or `forEach` on an array, V8 can optimize those operations based on what kind of elements the array contains.

https://v8.dev/blog/elements-kinds#common-elements-kinds

In other words, V8 can identify "fast arrays" and optimize arrays operations by avoiding unnecessary work.

> During his three-months internship on the V8 team, Hai Dang worked on improving the performance of...
> We implemented this simple idea using CSA for fast arrays, i.e. arrays with one of the six most common elements kinds.

https://v8.dev/blog/spread-elements

In other words, these optimizations are not always possible

For instance, if an array is dense or packed (ie. it does not contain holes) and every elements are small integers then

fast arrays, i.e. arrays with one of the six most common elements kinds.

common elements kinds

V8 developers traditionally wrote optimized builtins in assembly language. By using assembly, the hand-written builtin func

We implemented this simple idea using CSA for fast arrays

to make the code faster

We implemented this simple idea using CSA for fast arrays, i.e. arrays with one of the six most common elements kinds. The optimization applies for the common real-world scenario where the spread occurs at the start of the array literal, e.g. [...foo]. As shown in the graph below, this new fast path yields roughly a 3× performance improvement for spreading an array of length 100,000, making it about 25% faster than the hand-written clone loop.

////
> V8 Torque is a language that allows developers contributing to the V8 project to express changes in the VM by focusing on the intent of their changes to the VM, rather than preoccupying themselves with unrelated implementation details.
The language was designed to be simple enough to make it easy to directly translate the ECMAScript specification into an implementation in V8, but powerful enough to express the low-level V8 optimization tricks in a robust way, like creating fast-paths based on tests for specific object-shapes.

Torque compiler converts these morsels into efficient assembly code using the CodeStubAssembler
////

While reading the https://v8.dev/blog[V8 blog], I found this article related to arrays: https://v8.dev/blog/spread-elements.
This article does not explicitly talk about `Array.prototype.splice` but suggests that some work has been done to improve common operations on arrays in V8 version 7.2.
Interesting...

This article also mentions the https://v8.dev/blog/csa[CodeStubAssembler] component used to write robust and optimized JavaScript features.
Older versions of V8 called out to this JS-with-extensions code:
https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642 - I
don't speak for the V8 team but I don't believe they're looking to
return to that approach.

the fast path also applies when the spread elements are


> V8 Torque is a language that allows developers contributing to the V8 project to express changes in the VM by focusing on the intent of their changes to the VM, rather than preoccupying themselves with unrelated implementation details.
The language was designed to be simple enough to make it easy to directly translate the ECMAScript specification into an implementation in V8, but powerful enough to express the low-level V8 optimization tricks in a robust way, like creating fast-paths based on tests for specific object-shapes.

Torque compiler converts these morsels into efficient assembly code using the CodeStubAssembler

https://v8.dev/blog/elements-kinds#debugging

https://v8.dev/blog/csa



As mentioned in the
https://v8.dev/docs/torque

== Fast paths

Condition `IsPrototypeInitialArrayPrototype`
https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/builtins/base.tq#L1299

Torque implementation
https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/builtins/array-splice.tq#L125

FastJSArray

https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/builtins/base.tq#L1289-L1303

fast path https://github.com/v8/v8/blob/8ca2a7c83359f41bc990e4a2cf3a0edbc153cca8/src/codegen/code-stub-assembler.cc#L3653 but the code is only sound when
Array.prototype is unmodified, hence the IsPrototypeInitialArrayPrototype() check.

== Microbenchmarks

- Performance improvements (Array#splice faster on Node 12/14)
- Implementation changed and based on Torque (more strict about prototypes tampering)


node-v10.22.1 V8 version < 7.0
node-v14.12.0 V8 version 8.4

== Prototypes tampering

Changing the prototype of an object can be useful in some specific cases.
In this context, I'm using https://github.com/opal/opal[Opal] which relies on prototypes to augment built-in objects and implement Ruby inheritance model.

In fact, Opal will actually replace the prototype on the `Array` built-in object using `Object.setPrototypeOf`:

[source,js]
----
Object.setPrototypeOf(Array.prototype, Opal.Class.prototype)
----

Once you've done that, V8 won't use fast execution paths on Array functions anymore.
And, as you might have guessed, the performance of these functions will be poor (such as `shift`, `splice`, `slice`...).

At this point, you are probably thinking: "Just don’t mess with prototypes!".
And you are right but that's not always possible...

[NOTE]
====
If you want to learn more about JavaScript engines and how they optimize code, I highly recommend reading https://twitter.com/mathias[Mathias Bynens] blog posts:

- https://mathiasbynens.be/notes/shapes-ics[Shapes and inline caches]
- https://mathiasbynens.be/notes/prototypes[Optimizing prototypes]

The main takeaway is probably to leave prototypes alone!

> Based on this knowledge, we identified a practical JavaScript coding tip that can help boost performance:
don’t mess with prototypes (or if you really, really need to, then at least do it before other code runs)
-- Mathias Bynens

The excellent MDN Web Doc also warns us against https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf[`setPrototypeOf`].
====

== Microbenchmarks

So how much of a difference does it make when V8 is not using fast execution paths?

To find out let's run the same code with and without prototypes tampering on Node.js 14.12.0 (which uses V8 version 8.4).

NOTE: In the following examples, I'm using the great https://benchmarkjs.com/[`benchmark`] library.

[source,js]
----
include::example$js-array-performance/splice.js[]
----

....
$ node splice.js
splice x 17,968,510 ops/sec ±0.70% (91 runs sampled)
....

....
$ PROTOTYPE_TAMPERING=true node splice.js
splice x 795,132 ops/sec ±0.46% (95 runs sampled)
....

Well, that's not great... approximately 20x times slower.
Please note that your results may vary, but it should definitely be slower!

== Faster implementation

In summary, we cannot avoid using prototypes tampering and as a result we get bad performance because V8 cannot use fast execution paths. +
So, what can we do?

While looking for a solution, I stumbled across this commit in the Node.js repository on GitHub: https://github.com/nodejs/node/commit/d3f8db124463e478420d8bba6fa5cf13af7b4ecb
In this commit, Ben Noordhuis replaced the call to `Array#splice()` with a faster open-coded version:

[source,js]
----
include::example$js-array-performance/splice-one.js[tags=splice-one-function]
----

Please note that the above code is an optimization for the two-arguments version of `Array#splice()` when the second argument (`deleteCount`) is 1.
It's also worth noting that `Array#splice()` returns an array containing the deleted elements, while this optimized version returns `undefined`.
In other words, it's a specialized optimization of the `Array#splice()` function.

Let's give it a try:

[source,js]
----
include::example$js-array-performance/splice-one.js[tags=**]
----

....
$ PROTOTYPE_TAMPERING=true node splice-one.js
spliceOne x 15,719,180 ops/sec ±0.61% (92 runs sampled)
....

The performance are actually pretty good and roughly equivalent to what we had before messing around with prototypes.
Please note that even if you are not using prototypes tampering, this optimization is still 1.5x to 2x faster:

....
$ node splice-one.js
spliceOne x 35,553,964 ops/sec ±0.40% (91 runs sampled)
....

Before replacing every occurrence in your code I still recommend measuring the impact in your context.
Also, it's worth noting that `Array.splice` might be faster in future versions of V8.
In short, your mileage might vary.

== General optimization




== Next

In the next articles, we will see how to optimize `Array#shift`, `Array#unshift` and `Array#slice`.
